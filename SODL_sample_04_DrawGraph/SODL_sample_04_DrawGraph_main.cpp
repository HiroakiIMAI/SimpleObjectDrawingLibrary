#define  _USE_MATH_DEFINES

#include "include/SimpleObjectDrawingLibrary.h"
#pragma comment( lib, "SimpleObjectDrawLib.lib" )

#include <math.h>
#include <iostream>




namespace sodl = SmplObjDrwLib;

namespace app {
	// グローバル変数
	const int	WINDOW_SIZE_X = 1280;
	const int	WINDOW_SIZE_Y = 480;

	int mouse_x = 0;
	int mouse_y = 0;

	float ax_X = 100; // [mm]
	float ax_Y = 100; // [mm]
	float ax_Z = 100; // [mm]

	// Windowインタラクション関連コールバック関数
	void keyFunc(unsigned char key, int u, int v);
	void onMouseBtn(int button, int state, int x, int y);
	void onMouseDrag(int u, int v);
	void onMouseHover(int u, int v);

	// その他のサブ関数
	std::string GetModulePath();	// 実行ファイルのパスを取得

};


//================================================================
//
//	<Summry>		アプリケーションのエントリポイント
//	<Description>
//================================================================
int main(int argc, char ** argv) 
{
	sodl::DrawingManager::initMngr( &argc, argv, app::WINDOW_SIZE_X,app::WINDOW_SIZE_Y);
	
	sodl::drwMngr->SetMouseFunc(app::onMouseBtn);
	sodl::drwMngr->SetMouseDrag(app::onMouseDrag);
	sodl::drwMngr->SetPassiveMotionFunc(app::onMouseHover);
	sodl::drwMngr->SetKeyboardFunc(app::keyFunc);
	

	//////////////////////////////////////////////////////
	//
	// ビューポート1とカメラ1を調整する。(デフォルトの描画空間[0]を撮影する)
	// 3Dモデルをロードし、デフォルトの描画空間[0]に配置する。
	//
	//////////////////////////////////////////////////////
	// ビューポート1
	auto vp1 = sodl::drwMngr->viewPorts[0];
	vp1->setVpSize(
		0,			// left
		0,			// bottom
		app::WINDOW_SIZE_X/2,	// width
		app::WINDOW_SIZE_Y	// height
	);
	auto cam1 = vp1->getCam();
	cam1->camPos = Eigen::Vector3f(400.f, -400.f, 400.f);
	cam1->camTgt = Eigen::Vector3f(100.f, 100.f, 100.f);
	cam1->zoomRatio = 0.8;
	vp1->attachCam(cam1);

	//-----------------------------------------------------
	// ワールド座標系原点から連鎖するJ1~4座標系オブジェクトを定義
	//-----------------------------------------------------
	// ワールド座標系原点を定義
	auto World_Origin = sodl::CoordChainObj::create("World_Origin");
	World_Origin->CrdTrs.translation() = Eigen::Vector3f(0.f, 0.f, 0.f);

	// J1~4座標系を定義
	auto X_Link = sodl::CoordChainObj::create("X_Link", World_Origin);
	auto Y_Link = sodl::CoordChainObj::create("Y_Link", X_Link);
	auto Z_Link = sodl::CoordChainObj::create("Z_Link", Y_Link);

	//-----------------------------------------------------
	// 3Dモデルオブジェクトを座標系オブジェクトにアタッチする
	//-----------------------------------------------------
	// 実行ファイルのパスを取得する(モデルファイルの位置を相対パスで指定するため)
	std::string exePath = app::GetModulePath();
	// 3Dモデル描画付き座標系オブジェクトを生成
	auto model_Crd = sodl::CoordChain3dMdl::create(exePath + "3dModel\\miku.obj", "model_Crd", Z_Link);
	// アタッチしたZ_Linkとの相対位置を調整する
	model_Crd->CrdTrs.translation() = Eigen::Vector3f(0.f, 0.f, 10.f);

	//-----------------------------------------------------
	// 定義したオブジェクトを描画対象として描画マネージャに登録
	//-----------------------------------------------------
	// 定義した座標系連鎖を描画マネージャの持つデフォルトの描画空間にセット
	sodl::drwMngr->AddObjTree_ToDrwSpace(World_Origin);



	//////////////////////////////////////////////////////
	//
	// 追加の描画空間[1]を作成し、
	// ビューポート, カメラを設定する。
	//
	// 時系列グラフ(2次元)を作成し、
	// 追加の描画空間[1]に配置する。
	//
	//////////////////////////////////////////////////////
	{
		// グラフ用に描画空間[1]を追加
		auto spaceGrph = sodl::drwMngr->addDrawingSpace();

		// ビューポート
		auto vpGrph = sodl::drwMngr->addViewPort("vpTimeSerialGraph");
		vpGrph->spaceAttached = spaceGrph;
		vpGrph->setVpSize(
			app::WINDOW_SIZE_X/2,		// left
			app::WINDOW_SIZE_Y / 2,	// bottom
			app::WINDOW_SIZE_X/2,		// width
			app::WINDOW_SIZE_Y / 2		// height
		);
		// カメラ
		auto camGrph = vpGrph->getCam();
		camGrph->camPos = Eigen::Vector3f(0.f, 0.f, 10.f);
		camGrph->camTgt = Eigen::Vector3f(0.f, 0.f, 0.f);
		camGrph->camUpVec = Eigen::Vector3f(0.f, 1.f, 0.f);
		camGrph->SetPrjMtx_As2DView(200, 100);
	}
	// 時系列グラフの作成
	auto timeSerialGraph
		= sodl::TimeSeriesGraph::create(
			"TimeSerealGraph",
			std::weak_ptr<sodl::CoordChainObj>(),
			200,
			100
		);
	timeSerialGraph->rangeMax.x() = 0;
	timeSerialGraph->rangeMin.x() = 0;
	timeSerialGraph->rangeMax.y() = 100;
	timeSerialGraph->rangeMin.y() = -100;
	// 描画空間[1]にグラフを追加
	sodl::drwMngr->AddObjTree_ToDrwSpace(timeSerialGraph, 1);
	

	//////////////////////////////////////////////////////
	//
	// 追加の描画空間[2]を作成し、
	// ビューポート, カメラを設定する。
	//
	// 散布図グラフ(2次元)を作成し、
	// 追加の描画空間[2]に配置する。
	//
	//////////////////////////////////////////////////////
	{
		// グラフ用に描画空間[2]を追加
		auto spaceGrph = sodl::drwMngr->addDrawingSpace();
		// ビューポート
		auto vpGrph = sodl::drwMngr->addViewPort("vpScatterGraph");
		vpGrph->spaceAttached = spaceGrph;
		vpGrph->setVpSize(
			app::WINDOW_SIZE_X / 2,		// left
			0,							// bottom
			app::WINDOW_SIZE_Y / 2,		// width
			app::WINDOW_SIZE_Y / 2		// height
		);
		// カメラ
		auto camGrph = vpGrph->getCam();
		camGrph->camPos = Eigen::Vector3f(0.f, 0.f, 10.f);
		camGrph->camTgt = Eigen::Vector3f(0.f, 0.f, 0.f);
		camGrph->camUpVec = Eigen::Vector3f(0.f, 1.f, 0.f);
		camGrph->SetPrjMtx_As2DView(100, 100);
	}
	// 散布図グラフの作成
	auto scatterGraph = sodl::GraphObj::create("ScatterGraph");
	scatterGraph->rangeMax.x() = 100;
	scatterGraph->rangeMin.x() = -100;
	scatterGraph->rangeMax.y() = 100;
	scatterGraph->rangeMin.y() = -100;
	// 描画空間にグラフを追加
	sodl::drwMngr->AddObjTree_ToDrwSpace(scatterGraph, 2);
		

	//////////////////////////////////////////////////////
	//
	// 周期処理の実施
	//

	int count = 0;
	while(1)
	{
		// モデル座標を更新
		X_Link->CrdTrs.translation() = Eigen::Vector3f(app::ax_X, 0, 0);
		Y_Link->CrdTrs.translation() = Eigen::Vector3f(0, app::ax_Y, 0);
		Z_Link->CrdTrs.translation() = Eigen::Vector3f(0, 0, app::ax_Z);
		
		// モデルX座標＋ランダムノイズを時系列グラフにプロット
		timeSerialGraph->addData(Eigen::Vector3f(count, app::ax_X + rand()%100 - 50, -3));

		// ドラッグ中のマウス位置X,Yを散布図グラフにプロット
		scatterGraph->addData(Eigen::Vector3f(app::mouse_x, app::mouse_y, -3));

		// 描画更新
		sodl::drwMngr->drawUpdt();

		++count;
		Sleep(10);
	}

	return 0;
}


namespace app {

	//================================================================
	//
	//	<Summry>		キー操作時のコールバック
	//	<Description>
	//================================================================
	void keyFunc(unsigned char key, int u, int v)
	{
		const float		KEY_MOT_UNIT	=	5.f;
		const float		CNV_DEG2RAD		=	(M_PI / 180.f);

		switch (key) {
		case '\033':	// '\033' は ESC の ASCII コード
			exit(0);

		case '1':
			ax_X += KEY_MOT_UNIT;
			break;
		case '2':
			ax_Y += KEY_MOT_UNIT;
			break;
		case '3':
			ax_Z += KEY_MOT_UNIT;
			break;

		case 'q':
			ax_X -= KEY_MOT_UNIT;
			break;
		case 'w':
			ax_Y -= KEY_MOT_UNIT;
			break;
		case 'e':
			ax_Z -= KEY_MOT_UNIT;
			break;


		default:
			break;
		}
	}

	//================================================================
	//
	//	<Summry>		GLウィンドウ上でマウスボタン操作時のコールバック
	//	<Description>
	//================================================================
	void onMouseBtn(int button, int state, int x, int y)
	{
	}

	//================================================================
	//
	//	<Summry>		GLウィンドウ上でマウスドラッグ時のコールバック
	//	<Description>
	//================================================================
	void onMouseDrag(int u, int v)
	{
		mouse_x = u;
		mouse_y = WINDOW_SIZE_Y - v;
	}

	//================================================================
	//
	//	<Summry>		GLウィンドウ上でマウスホバー時のコールバック
	//	<Description>
	//================================================================
	void onMouseHover(int u, int v)
	{
	}


	//================================================================
	//
	//	<Summry>		実行ファイルのパスを取得
	//	<Description>
	//================================================================
	std::string GetModulePath()
	{
		// 実行ファイルのパス
		std::string modulePath = "";
		// ドライブ名、ディレクトリ名、ファイル名、拡張子
		char path[MAX_PATH], drive[MAX_PATH], dir[MAX_PATH], fname[MAX_PATH], ext[MAX_PATH];

		// 実行ファイルのファイルパスを取得
		if (GetModuleFileNameA(NULL, path, MAX_PATH) != 0)
		{
			// ファイルパスを分割
			_splitpath_s(path, drive, dir, fname, ext);
			// ドライブとディレクトリ名を結合して実行ファイルパスとする
			modulePath = std::string(drive) + std::string(dir);
		}

		return modulePath;
	}

};
